<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A buffered MPSC “swap-buffer” queue."><meta name="keywords" content="rust, rustlang, rust-lang, SBQueue"><title>SBQueue in swap_buffer_queue - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../swap_buffer_queue/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../swap_buffer_queue/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">SBQueue</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.capacity">capacity</a></li><li><a href="#method.close">close</a></li><li><a href="#method.dequeue">dequeue</a></li><li><a href="#method.dequeue-1">dequeue</a></li><li><a href="#method.enqueue">enqueue</a></li><li><a href="#method.enqueue-1">enqueue</a></li><li><a href="#method.is_closed">is_closed</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.len">len</a></li><li><a href="#method.new">new</a></li><li><a href="#method.notify">notify</a></li><li><a href="#method.reopen">reopen</a></li><li><a href="#method.try_dequeue">try_dequeue</a></li><li><a href="#method.try_dequeue_and_resize">try_dequeue_and_resize</a></li><li><a href="#method.try_dequeue_timeout">try_dequeue_timeout</a></li><li><a href="#method.try_enqueue">try_enqueue</a></li><li><a href="#method.try_enqueue_timeout">try_enqueue_timeout</a></li><li><a href="#method.with_capacity">with_capacity</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-SBQueue%3CB%2C%20T%2C%20N%3E">Debug</a></li><li><a href="#impl-Default-for-SBQueue%3CB%2C%20T%2C%20N%3E">Default</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-SBQueue%3CB%2C%20T%2C%20N%3E">Send</a></li><li><a href="#impl-Sync-for-SBQueue%3CB%2C%20T%2C%20N%3E">Sync</a></li><li><a href="#impl-Unpin-for-SBQueue%3CB%2C%20T%2C%20N%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-SBQueue%3CB%2C%20T%2C%20N%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In swap_buffer_queue</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">swap_buffer_queue</a>::<wbr><a class="struct" href="#">SBQueue</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/swap_buffer_queue/queue.rs.html#15-23">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust struct"><code>pub struct SBQueue&lt;B, T, N&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,</span>{ /* private fields */ }</code></pre></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A buffered MPSC “swap-buffer” queue.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#25-48">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#40-47">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Create a new queue using buffer default.</p>
<p>Buffer default may have a non-zero capacity, e.g. array buffer.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::new();</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20N%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#50-74">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20N%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt; + <a class="trait" href="buffer/trait.Resizable.html" title="trait swap_buffer_queue::buffer::Resizable">Resizable</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_capacity" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#63-73">source</a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fn">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new queue with the given capacity.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20N%3E-2" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#76-179">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20N%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.notify" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#91-93">source</a><h4 class="code-header">pub fn <a href="#method.notify" class="fn">notify</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>N</h4></section></summary><div class="docblock"><p>Create a new queue with the given capacity.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>swap_buffer_queue::notify::Notify;

<span class="kw">let </span>queue: AsyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = AsyncSBQueue::with_capacity(<span class="number">42</span>);
queue.notify().notify_dequeue();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capacity" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#108-110">source</a><h4 class="code-header">pub fn <a href="#method.capacity" class="fn">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the current buffer capacity.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">42</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#123-125">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the current buffer length.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(queue.len(), <span class="number">0</span>);
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(queue.len(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#136-138">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the current buffer is empty.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
<span class="macro">assert!</span>(queue.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_closed" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#151-153">source</a><h4 class="code-header">pub fn <a href="#method.is_closed" class="fn">is_closed</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the queue is closed.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
<span class="macro">assert!</span>(!queue.is_closed());
queue.close();
<span class="macro">assert!</span>(queue.is_closed());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reopen" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#169-172">source</a><h4 class="code-header">pub fn <a href="#method.reopen" class="fn">reopen</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Reopen a closed queue.</p>
<p>Calling this method when the queue is not closed has no effect.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
queue.close();
<span class="macro">assert!</span>(queue.is_closed());
queue.reopen();
<span class="macro">assert!</span>(!queue.is_closed());</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20N%3E-3" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#181-384">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20N%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="notify/trait.Notify.html" title="trait swap_buffer_queue::notify::Notify">Notify</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_enqueue" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#207-234">source</a><h4 class="code-header">pub fn <a href="#method.try_enqueue" class="fn">try_enqueue</a>(&amp;self, value: T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="error/enum.TryEnqueueError.html" title="enum swap_buffer_queue::error::TryEnqueueError">TryEnqueueError</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Tries enqueuing the given value into the queue.</p>
<p>Enqueuing will fail if the queue has insufficient capacity, or if it is closed. In case of
success, it will notify waiting dequeuing operations using <a href="notify/trait.Notify.html#tymethod.notify_dequeue" title="Notify::notify_dequeue"><code>Notify::notify_dequeue</code></a>.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">1</span>);
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="comment">// queue is full
</span><span class="macro">assert_eq!</span>(
    queue.try_enqueue(<span class="number">0</span>),
    <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(<span class="number">0</span>))
);
<span class="comment">// let&#39;s close the queue
</span>queue.close();
<span class="macro">assert_eq!</span>(queue.try_enqueue(<span class="number">0</span>), <span class="prelude-val">Err</span>(TryEnqueueError::Closed(<span class="number">0</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_dequeue" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#353-358">source</a><h4 class="code-header">pub fn <a href="#method.try_dequeue" class="fn">try_dequeue</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="buffer/struct.BufferSlice.html" title="struct swap_buffer_queue::buffer::BufferSlice">BufferSlice</a>&lt;'_, B, T, N&gt;, <a class="enum" href="error/enum.TryDequeueError.html" title="enum swap_buffer_queue::error::TryDequeueError">TryDequeueError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries dequeuing a buffer with all enqueued values from the queue.</p>
<p>This method swaps the current buffer with the other one, which is empty. All concurrent
insertions must end before the the current buffer is really dequeuable, so the queue may
be in a transitory state where <code>try_dequeue</code> must be retried. In this state, after a spin
loop, this method will return a <a href="error/enum.TryDequeueError.html#variant.Pending" title="TryDequeueError::Pending"><code>TryDequeueError::Pending</code></a> error.</p>
<p>Dequeuing also fails if the queue is empty, or if it is closed. Moreover, as the algorithm
is MPSC, dequeuing is protected against concurrent calls, failing with
<a href="error/enum.TryDequeueError.html#variant.Conflict" title="TryDequeueError::Conflict"><code>TryDequeueError::Conflict</code></a> error.</p>
<p>It returns a <a href="buffer/struct.BufferSlice.html" title="BufferSlice"><code>BufferSlice</code></a>, which holds, as its name may indicate, a reference to the
dequeued buffer. That’s why, the concurrent dequeuing protection is maintained for the
lifetime of the buffer slice.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
queue.try_enqueue(<span class="number">0</span>).unwrap();
queue.try_enqueue(<span class="number">1</span>).unwrap();
<span class="kw">let </span>slice = queue.try_dequeue().unwrap();
<span class="macro">assert_eq!</span>(slice.deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">// dequeuing cannot be done concurrently (`slice` is still in scope)
</span><span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap_err(), TryDequeueError::Conflict);
drop(slice);
<span class="comment">// let&#39;s close the queue
</span>queue.try_enqueue(<span class="number">2</span>).unwrap();
queue.close();
<span class="comment">// queue can be dequeued while closed when not empty
</span><span class="kw">let </span>slice = queue.try_dequeue().unwrap();
<span class="macro">assert_eq!</span>(slice.deref(), <span class="kw-2">&amp;</span>[<span class="number">2</span>]);
drop(slice);
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap_err(), TryDequeueError::Closed)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.close" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#379-383">source</a><h4 class="code-header">pub fn <a href="#method.close" class="fn">close</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Closes the queue.</p>
<p>Closed queue can no more accept enqueuing, but it can be dequeued while not empty.
Calling this method on a closed queue has no effect.
See <a href="struct.SBQueue.html#method.reopen"><code>reopen</code></a> to reopen a closed queue.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">42</span>);
queue.try_enqueue(<span class="number">0</span>).unwrap();
queue.close();
<span class="macro">assert!</span>(queue.is_closed());
<span class="macro">assert_eq!</span>(queue.try_enqueue(<span class="number">1</span>), <span class="prelude-val">Err</span>(TryEnqueueError::Closed(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap_err(), TryDequeueError::Closed);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20N%3E-4" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#386-515">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20N%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt; + <a class="trait" href="buffer/trait.Resizable.html" title="trait swap_buffer_queue::buffer::Resizable">Resizable</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="notify/trait.Notify.html" title="trait swap_buffer_queue::notify::Notify">Notify</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_dequeue_and_resize" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#502-514">source</a><h4 class="code-header">pub fn <a href="#method.try_dequeue_and_resize" class="fn">try_dequeue_and_resize</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;insert: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="buffer/struct.BufferSlice.html" title="struct swap_buffer_queue::buffer::BufferSlice">BufferSlice</a>&lt;'_, B, T, N&gt;, <a class="enum" href="error/enum.TryDequeueError.html" title="enum swap_buffer_queue::error::TryDequeueError">TryDequeueError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries dequeuing a buffer with all enqueued values from the queue, and resizes the next
buffer to be used for enqueuing.</p>
<p>This method is an extension of <a href="struct.SBQueue.html#method.try_dequeue"><code>try_dequeue</code></a> method. In fact,
before swapping the buffers, next one is empty and protected, so it can be resized, and
it is also possible to add values in it before making it available for enqueuing.
This can be used to make the queue <a href="struct.SBQueue.html#an-amortized-unbounded-recipe">unbounded</a>.</p>
<p>It is  worth to be noted that buffer is resized even if the queue is empty; in this case,
buffer will be swapped, whereas it would not be the case with
<a href="struct.SBQueue.html#method.try_dequeue"><code>try_dequeue</code></a> method call on an empty queue.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::with_capacity(<span class="number">1</span>);
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="comment">// queue is full
</span><span class="macro">assert_eq!</span>(
    queue.try_enqueue(<span class="number">1</span>),
    <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(<span class="number">1</span>))
);
<span class="comment">// dequeue and resize, inserting elements before the buffer is available
</span><span class="kw">let </span>slice = queue
    .try_dequeue_and_resize(<span class="number">3</span>, <span class="prelude-val">Some</span>(std::iter::once(<span class="number">42</span>)))
    .unwrap();
<span class="macro">assert_eq!</span>(slice.deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
drop(slice);
<span class="comment">// capacity has been increased
</span>queue.try_enqueue(<span class="number">1</span>).unwrap();
queue.try_enqueue(<span class="number">2</span>).unwrap();
<span class="kw">let </span>slice = queue.try_dequeue().unwrap();
<span class="macro">assert_eq!</span>(slice.deref(), <span class="kw-2">&amp;</span>[<span class="number">42</span>, <span class="number">1</span>, <span class="number">2</span>]);</code></pre></div>
<h6 id="an-amortized-unbounded-recipe"><a href="#an-amortized-unbounded-recipe">An amortized unbounded recipe</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>enqueue_unbounded&lt;T&gt;(
    queue: <span class="kw-2">&amp;</span>SBQueue&lt;VecBuffer&lt;T&gt;, T&gt;,
    overflow: <span class="kw-2">&amp;</span>Mutex&lt;Vec&lt;T&gt;&gt;,
    <span class="kw-2">mut </span>value: T,
) -&gt; <span class="prelude-ty">Result</span>&lt;(), EnqueueError&lt;T&gt;&gt; {
    <span class="comment">// first, try to enqueue normally
    </span><span class="kw">match </span>queue.try_enqueue(value) {
        <span class="prelude-val">Ok</span>(()) =&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(()),
        <span class="prelude-val">Err</span>(TryEnqueueError::Closed(v)) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(EnqueueError(v)),
        <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(v)) =&gt; value = v,
    };
    <span class="comment">// if the enqueuing fails, lock the overflow
    </span><span class="kw">let </span><span class="kw-2">mut </span>guard = overflow.lock().unwrap();
    <span class="comment">// retry to enqueue (we never know what happened during lock acquisition)
    </span><span class="kw">match </span>queue.try_enqueue(value) {
        <span class="prelude-val">Ok</span>(()) =&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(()),
        <span class="prelude-val">Err</span>(TryEnqueueError::Closed(v)) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(EnqueueError(v)),
        <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(v)) =&gt; value = v,
    };
    <span class="comment">// then push the values to the overflow vector
    </span>guard.push(value);
    <span class="comment">// notify possible waiting dequeue
    </span>queue.notify().notify_dequeue();
    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>try_dequeue_unbounded&lt;<span class="lifetime">&#39;a</span>, T&gt;(
    queue: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>SBQueue&lt;VecBuffer&lt;T&gt;, T&gt;,
    overflow: <span class="kw-2">&amp;</span>Mutex&lt;Vec&lt;T&gt;&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;BufferSlice&lt;<span class="lifetime">&#39;a</span>, VecBuffer&lt;T&gt;, T, ()&gt;, TryDequeueError&gt; {
    <span class="comment">// lock the overflow and use `try_dequeue_and_resize` to drain the overflow into the
    // queue
    </span><span class="kw">let </span><span class="kw-2">mut </span>guard = overflow.lock().unwrap();
    queue.try_dequeue_and_resize(queue.capacity() + guard.len(), <span class="prelude-val">Some</span>(guard.drain(..)))
}

<span class="comment">// queue is initialized with zero capacity
</span><span class="kw">let </span>queue: SBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt; = SBQueue::new();
<span class="kw">let </span>overflow = Mutex::new(Vec::new());
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">0</span>);
enqueue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    try_dequeue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow).unwrap_err(),
    TryDequeueError::Empty
);
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(queue.len(), <span class="number">1</span>);
enqueue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow, <span class="number">1</span>).unwrap();
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(queue.len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(overflow.lock().unwrap().len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    try_dequeue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow).unwrap().deref(),
    <span class="kw-2">&amp;</span>[<span class="number">0</span>]
);
<span class="macro">assert_eq!</span>(queue.capacity(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(queue.len(), <span class="number">1</span>);
enqueue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow, <span class="number">2</span>).unwrap();
<span class="macro">assert_eq!</span>(
    try_dequeue_unbounded(<span class="kw-2">&amp;</span>queue, <span class="kw-2">&amp;</span>overflow).unwrap().deref(),
    <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>]
);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20AsyncNotifier%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/async.rs.html#31-135">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20AsyncNotifier%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, <a class="struct" href="async/struct.AsyncNotifier.html" title="struct swap_buffer_queue::async::AsyncNotifier">AsyncNotifier</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.enqueue" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/async.rs.html#71-81">source</a><h4 class="code-header">pub async fn <a href="#method.enqueue" class="fn">enqueue</a>(&amp;self, value: T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="error/struct.EnqueueError.html" title="struct swap_buffer_queue::error::EnqueueError">EnqueueError</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>async</code></strong> only.</div></span></summary><div class="docblock"><p>Enqueues the given value inside the queue.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_enqueue"><code>try_enqueue</code></a> by waiting asynchronously
<a href="async/struct.AsyncNotifier.html#method.notify_enqueue" title="AsyncNotifier::notify_enqueue"><code>AsyncNotifier::notify_enqueue</code></a> call, i.e. when a buffer is dequeued, in case of
insufficient capacity.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;AsyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; =
    Arc::new(AsyncSBQueue::with_capacity(<span class="number">1</span>));
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(
    queue.try_enqueue(<span class="number">0</span>),
    <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(<span class="number">0</span>))
);
<span class="comment">// queue is full, let&#39;s spawn an enqueuing task and dequeue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = tokio::spawn(<span class="kw">async move </span>{ queue_clone.enqueue(<span class="number">1</span>).<span class="kw">await </span>});
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="comment">// enqueuing task has succeeded
</span>task.<span class="kw">await</span>.unwrap().unwrap();
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="comment">// let&#39;s close the queue
</span>queue.try_enqueue(<span class="number">2</span>).unwrap();
<span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = tokio::spawn(<span class="kw">async move </span>{ queue_clone.enqueue(<span class="number">3</span>).<span class="kw">await </span>});
queue.close();
<span class="macro">assert_eq!</span>(task.<span class="kw">await</span>.unwrap(), <span class="prelude-val">Err</span>(EnqueueError(<span class="number">3</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dequeue" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/async.rs.html#117-134">source</a><h4 class="code-header">pub async fn <a href="#method.dequeue" class="fn">dequeue</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="buffer/struct.BufferSlice.html" title="struct swap_buffer_queue::buffer::BufferSlice">BufferSlice</a>&lt;'_, B, T, <a class="struct" href="async/struct.AsyncNotifier.html" title="struct swap_buffer_queue::async::AsyncNotifier">AsyncNotifier</a>&gt;, <a class="enum" href="error/enum.DequeueError.html" title="enum swap_buffer_queue::error::DequeueError">DequeueError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>async</code></strong> only.</div></span></summary><div class="docblock"><p>Dequeues a buffer with all enqueued values from the queue.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_dequeue"><code>try_dequeue</code></a> by waiting asynchronously
<a href="async/struct.AsyncNotifier.html#method.notify_dequeue" title="AsyncNotifier::notify_dequeue"><code>AsyncNotifier::notify_dequeue</code></a> call, i.e. when a value is enqueued, in case of
empty queue.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;AsyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; =
    Arc::new(AsyncSBQueue::with_capacity(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap_err(), TryDequeueError::Empty);
<span class="comment">// queue is empty, let&#39;s spawn a dequeuing task and enqueue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = tokio::spawn(<span class="kw">async move </span>{
    <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, DequeueError&gt;(queue_clone.dequeue().<span class="kw">await</span><span class="question-mark">?</span>.into_iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;())
});
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="comment">// dequeuing task has succeeded
</span><span class="macro">assert_eq!</span>(task.<span class="kw">await</span>.unwrap().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="comment">// let&#39;s close the queue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = tokio::spawn(<span class="kw">async move </span>{
    <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, DequeueError&gt;(queue_clone.dequeue().<span class="kw">await</span><span class="question-mark">?</span>.into_iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;())
});
queue.close();
<span class="macro">assert_eq!</span>(task.<span class="kw">await</span>.unwrap().unwrap_err(), DequeueError::Closed);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SBQueue%3CB%2C%20T%2C%20SyncNotifier%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/sync.rs.html#41-272">source</a><a href="#impl-SBQueue%3CB%2C%20T%2C%20SyncNotifier%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T&gt; <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, <a class="struct" href="sync/struct.SyncNotifier.html" title="struct swap_buffer_queue::sync::SyncNotifier">SyncNotifier</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_enqueue_timeout" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/sync.rs.html#120-126">source</a><h4 class="code-header">pub fn <a href="#method.try_enqueue_timeout" class="fn">try_enqueue_timeout</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;value: T,<br>&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="error/enum.TryEnqueueError.html" title="enum swap_buffer_queue::error::TryEnqueueError">TryEnqueueError</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>sync</code></strong> only.</div></span></summary><div class="docblock"><p>Tries enqueuing the given value inside the queue with a timeout.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_enqueue"><code>try_enqueue</code></a> by waiting synchronously, with a
timeout, <a href="sync/struct.SyncNotifier.html#method.notify_enqueue" title="SyncNotifier::notify_enqueue"><code>SyncNotifier::notify_enqueue</code></a> call, i.e. when a buffer is dequeued, in case of
insufficient capacity.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;SyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; = Arc::new(SyncSBQueue::with_capacity(<span class="number">1</span>));
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(
    queue.try_enqueue_timeout(<span class="number">1</span>, Duration::from_millis(<span class="number">1</span>)),
    <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(<span class="number">1</span>))
);
<span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| {
    std::thread::sleep(Duration::from_millis(<span class="number">1</span>));
    queue_clone.try_dequeue().unwrap();
});
queue
    .try_enqueue_timeout(<span class="number">1</span>, Duration::from_secs(<span class="number">1</span>))
    .unwrap();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.enqueue-1" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/sync.rs.html#161-167">source</a><h4 class="code-header">pub fn <a href="#method.enqueue-1" class="fn">enqueue</a>(&amp;self, value: T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="error/struct.EnqueueError.html" title="struct swap_buffer_queue::error::EnqueueError">EnqueueError</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>sync</code></strong> only.</div></span></summary><div class="docblock"><p>Enqueues the given value inside the queue.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_enqueue"><code>try_enqueue</code></a> by waiting synchronously
<a href="sync/struct.SyncNotifier.html#method.notify_enqueue" title="SyncNotifier::notify_enqueue"><code>SyncNotifier::notify_enqueue</code></a> call, i.e. when a buffer is dequeued, in case of
insufficient capacity.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;SyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; = Arc::new(SyncSBQueue::with_capacity(<span class="number">1</span>));
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(
    queue.try_enqueue(<span class="number">1</span>),
    <span class="prelude-val">Err</span>(TryEnqueueError::InsufficientCapacity(<span class="number">1</span>))
);
<span class="comment">// queue is full, let&#39;s spawn an enqueuing task and dequeue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| queue_clone.enqueue(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="comment">// enqueuing task has succeeded
</span>task.join().unwrap().unwrap();
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="comment">// let&#39;s close the queue
</span>queue.try_enqueue(<span class="number">2</span>).unwrap();
<span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| queue_clone.enqueue(<span class="number">3</span>));
queue.close();
<span class="macro">assert_eq!</span>(task.join().unwrap(), <span class="prelude-val">Err</span>(EnqueueError(<span class="number">3</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_dequeue_timeout" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/sync.rs.html#226-231">source</a><h4 class="code-header">pub fn <a href="#method.try_dequeue_timeout" class="fn">try_dequeue_timeout</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="buffer/struct.BufferSlice.html" title="struct swap_buffer_queue::buffer::BufferSlice">BufferSlice</a>&lt;'_, B, T, <a class="struct" href="sync/struct.SyncNotifier.html" title="struct swap_buffer_queue::sync::SyncNotifier">SyncNotifier</a>&gt;, <a class="enum" href="error/enum.TryDequeueError.html" title="enum swap_buffer_queue::error::TryDequeueError">TryDequeueError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>sync</code></strong> only.</div></span></summary><div class="docblock"><p>Tries dequeuing a buffer with all enqueued values from the queue with a timeout.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_dequeue"><code>try_dequeue</code></a> by waiting synchronously, with a
timeout, <a href="sync/struct.SyncNotifier.html#method.notify_dequeue" title="SyncNotifier::notify_dequeue"><code>SyncNotifier::notify_dequeue</code></a> call, i.e. when a value is enqueued, in case of
empty queue.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;SyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; = Arc::new(SyncSBQueue::with_capacity(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(
    queue
        .try_dequeue_timeout(Duration::from_millis(<span class="number">1</span>))
        .unwrap_err(),
    TryDequeueError::Empty
);
<span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| {
    std::thread::sleep(Duration::from_millis(<span class="number">1</span>));
    queue_clone.try_enqueue(<span class="number">0</span>).unwrap();
});
<span class="macro">assert_eq!</span>(
    queue
        .try_dequeue_timeout(Duration::from_secs(<span class="number">1</span>))
        .unwrap()
        .deref(),
    <span class="kw-2">&amp;</span>[<span class="number">0</span>]
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dequeue-1" class="method has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/sync.rs.html#264-271">source</a><h4 class="code-header">pub fn <a href="#method.dequeue-1" class="fn">dequeue</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="buffer/struct.BufferSlice.html" title="struct swap_buffer_queue::buffer::BufferSlice">BufferSlice</a>&lt;'_, B, T, <a class="struct" href="sync/struct.SyncNotifier.html" title="struct swap_buffer_queue::sync::SyncNotifier">SyncNotifier</a>&gt;, <a class="enum" href="error/enum.DequeueError.html" title="enum swap_buffer_queue::error::DequeueError">DequeueError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>sync</code></strong> only.</div></span></summary><div class="docblock"><p>Dequeues a buffer with all enqueued values from the queue.</p>
<p>This method extends <a href="struct.SBQueue.html#method.try_dequeue"><code>try_dequeue</code></a> by waiting synchronously
<a href="sync/struct.SyncNotifier.html#method.notify_dequeue" title="SyncNotifier::notify_dequeue"><code>SyncNotifier::notify_dequeue</code></a> call, i.e. when a value is enqueued, in case of
empty queue.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>queue: Arc&lt;SyncSBQueue&lt;VecBuffer&lt;usize&gt;, usize&gt;&gt; = Arc::new(SyncSBQueue::with_capacity(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(queue.try_dequeue().unwrap_err(), TryDequeueError::Empty);
<span class="comment">// queue is empty, let&#39;s spawn a dequeuing task and enqueue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| {
    <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, DequeueError&gt;(queue_clone.dequeue()<span class="question-mark">?</span>.into_iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;())
});
queue.try_enqueue(<span class="number">0</span>).unwrap();
<span class="comment">// dequeuing task has succeeded
</span><span class="macro">assert_eq!</span>(task.join().unwrap().unwrap().deref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="comment">// let&#39;s close the queue
</span><span class="kw">let </span>queue_clone = queue.clone();
<span class="kw">let </span>task = std::thread::spawn(<span class="kw">move </span>|| {
    <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, DequeueError&gt;(queue_clone.dequeue()<span class="question-mark">?</span>.into_iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;())
});
queue.close();
<span class="macro">assert_eq!</span>(task.join().unwrap().unwrap_err(), DequeueError::Closed);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#536-547">source</a><a href="#impl-Debug-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#541-546">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#526-534">source</a><a href="#impl-Default-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="buffer/trait.Buffer.html" title="trait swap_buffer_queue::buffer::Buffer">Buffer</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/swap_buffer_queue/queue.rs.html#531-533">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a href="#impl-Send-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a href="#impl-Sync-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a href="#impl-Unpin-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a href="#impl-UnwindSafe-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;B, T, N&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.SBQueue.html" title="struct swap_buffer_queue::SBQueue">SBQueue</a>&lt;B, T, N&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-SBQueue%3CB%2C%20T%2C%20N%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="swap_buffer_queue" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (9e75dddf6 2023-01-15)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>